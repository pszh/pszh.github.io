{"meta":{"title":"pszh blog","subtitle":"subtitle","description":"description","author":"pszh","url":"https://pszh.github.io"},"pages":[{"title":"categories","date":"2019-01-17T07:59:50.000Z","updated":"2019-01-17T08:23:45.609Z","comments":false,"path":"categories/index.html","permalink":"https://pszh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-17T07:59:13.000Z","updated":"2019-01-17T08:24:38.115Z","comments":false,"path":"tags/index.html","permalink":"https://pszh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack","slug":"webpack学习","date":"2020-01-16T02:06:24.654Z","updated":"2020-01-16T02:06:24.655Z","comments":true,"path":"2020/01/16/webpack学习/","link":"","permalink":"https://pszh.github.io/2020/01/16/webpack学习/","excerpt":"","text":"webpack 基础篇### 安装本地webpack webpack webpack-cli -D ​ https://www.webpackjs.com/concepts/#%E6%8F%92%E4%BB%B6-plugins- entry output loader plugins mode resolve https://webpack.js.org/configuration/resolve/#root 1234567resolve:&#123; alias: &#123; // 别名， import a from './src/utils/a.js' 简写 import a from 'utils/a.js' utils: path.resolve(__dirname, 'src/utils/'), Templates: path.resolve(__dirname, 'src/templates/') &#125; extensions: ['.js', '.vue', '.css', '.json'] // 引入文件时候没有后缀名会按照这个次序去找&#125; 开发服务器配置 webpack-dev-server​ 原理：启动了一个 express 的静态服务 123456789101112//更多配置 https://webpack.js.org/configuration/dev-server/devServer:&#123; port:3000, //默认是8080 progress:true, contentBase:'./build', //以这个文件作为目录去启动静态服务 proxy: &#123; //接口的代理设置 '/api': &#123; target: 'http://localhost:3000', pathRewrite: &#123;'^/api' : ''&#125; &#125; &#125;&#125; 使用插件 htmlwebpackPlugin 去自动引用模版 htmlwebpackPlugin https://webpack.js.org/plugins/html-webpack-plugin/#root 配置 ：https://github.com/jantimon/html-webpack-plugin#options 基本使用 123456789new HtmlWebpacklugin(&#123; template: \"./src/index.html\", filename: \"index.html\", //输出后的文件名 minify: &#123; // 在 mode:'production', 时候压缩html配置 removeAttributeQuotes: true, //双引号 collapseInlineTagWhitespace: true //压缩成一行 &#125;&#125;); loader 非 js 文件的处理 , 高级 js 语法转化css 处理1234567891011121314151617181920212223242526272829303132333435363738394041//loder的解析module:&#123; // 模块 rules:[ //规则 css-loader 接续 @import这种语法 // style-loader 把css插入到head的标签中 //loader 特点: 功能单一； 用法 ：一个loader用字符串，多个[]；顺序：默认从右往左 &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\", options: &#123; insertAt: \"top\" &#125; &#125;, //传对象这样写， inserAt css插入的位置 \"css-loader\" ] &#125; ]&#125;// mini-css-extract-plugin 的单独打包// https://webpack.js.org/plugins/mini-css-extract-plugin/#rootplugins: [ new MiniCssExtractPlugin(&#123; filename: 'main.css', &#125;),],module:&#123; rules:[ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'//浏览器前缀 postcss-loader ,autoprefixer ] &#125; ]&#125;// 打包后css压缩，optimize-css-assets-webpack-plugin, js压缩是 mode :\"production\" //https://www.npmjs.com/package/optimize-css-assets-webpack-pluginplugins: [ ... new optimizeCss(&#123;&#125;)] es6 转 es5babel-loader @babel/core : babel 的核心方法，可以调用 transform @babel/preset-env ：如何转化 es6=》es5 （ 按需编译和按需打补丁） 123456789101112&#123; test: /\\.js$/, use: &#123; loader: \"babel-loader\", options: &#123; // 用babel-loader 把es6-es5 presets: [\"@babel/preset-env\"] &#125; &#125; include:path.resolve(__dirname,'src'), exclude:/node_modules/&#125; //其他插件可以去 babel 官网查看 @babel/plugin-transform-runtime：是对 Babel 编译过程中产生的 helper 方法进行重新利用(聚合)，以达到减少打包体积的目的。此外还有个作用是为了避免全局补丁污染，对打包过的 bunler 提供”沙箱”式的补丁。配合产线的 @babel/runtime （放生产包，安装不要加 —D） polyfill(弃用)：core-js + regenerator core-js：实现 JavaScript 标准运行库之一，它提供了从 ES3 ～ ES7+ 以及还处在提案阶段的 JavaScript 的实现 babel 社区介绍 esLint 代码规范引用安装 eslint, aslant-loader 1234567891011rules: [ &#123; test: /\\.js$/, use: &#123; loader: \"eslint-loader\", options: &#123; enforce: \"pre\" // loader默认从右到左，下到上， pre:提前执行， post：往后 &#125; &#125; &#125;]; 图片处理12345678910111213141516171819202122232425262728// 三种 打包图片// 1)在js中创建图片import image from \"./image.jpg\"; //引入图片，返回一个新地址 （file-loader）为了可以根据图片大小把图片编译成base64 所以用url-loaderlet img = new Image();img.src = image;document.body.appendChild(img);//webpack.config中配置&#123; test: /\\.(png|jpg|gif)$/, // 做一个限制，图片小于 多少k时候，用base64来转化，其他用真实图片 // 否则用file-loader产生真实图片 use: &#123; loader: \"url-loader\", options: &#123; limit: 10 * 1024 &#125; &#125;&#125;,// 2）在css引入background（'url'） // css-loader会操作background-image: url(\"./image.jpg\");// 3) &lt;img src=\"./image.jpg\" /img&gt; //使用html-withimg-loader 注意 HtmlWebpacklugin 中的 minify配置就不能使用了,目前打包的时候 src 后面打包成对象了，还是有问题&#123; test: /\\.html$/, use: \"html-withimg-loader\"&#125;, 全局变量1） expose-loader 暴露到 window 上 2)providePlugin 给每个人提供一个\\$ 场景：在模块中不用引入 jqury 包就可以使用\\$ webpack 配置： 1234const webpack = require(\"webpack\");new webpack.ProvidePlugin(&#123; $: \"jquery\"&#125;); 引入不打包 cdn 在 html 中引入 文件分类在 mode:”production”，其他不要加 图片 123456789101112&#123; test: /\\.(png|jpg|gif)$/, // 做一个限制，图片小于 多少k时候，用base64来转化 // 否则用file-loader产生真实图片 use: &#123; loader: \"url-loader\", options: &#123; limit: 10 * 1024, outputPath:'img/' //打包路径 &#125; &#125;&#125;, 2） css 123new miniCssExtractPlugiin(&#123; filename: \"css/main.css\" &#125;), cdn 资源引入 123456789101112131415161718192021output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"output[hash:8].js\", //使用hash值 \"output[hash:8].js\" publicPath:'http://www.pszh.com', //给打包后的js,css,image图片都加上cdn路径 &#125;, // 如果只想给图片添加 &#123; test: /\\.(png|jpg|gif)$/, // 做一个限制，图片小于 多少k时候，用base64来转化 // 否则用file-loader产生真实图片 use: &#123; loader: \"url-loader\", options: &#123; limit: 10 * 1024, outputPath:'img/', //打包路径 publicPath:'http://www.pszh.com', &#125; &#125; &#125;, 配置篇打包多页应用12345678910111213141516171819202122232425entry: &#123; home: \"./src/home.js\", other: \"./src/other.js\" &#125;, output: &#123; //[name]表示变量 home ,other. entry的key值 filename: \"[name].js\", path: path.resolve(__dirname, \"dist\") &#125;, //打包出两个html文件 plugins: [ new htmlwebpackPlugin(&#123; template: \"./src/index.html\", filename: \"home.html\", //为了打包的时候只打包home.js进去 chunks: [\"home\"] &#125;), new htmlwebpackPlugin(&#123; template: \"./src/index.html\", filename: \"other.html\", //为了打包的时候把home.js，other.js都打进去 chunks: [\"home\", \"other\"] &#125;) ] 配置 source-map​ 源码映射 12345678//1)源码映射， 单独生成一个.map文件，出错会定位到报错的行和列 文件大且全 //devtool: \"source-map\", // 2) 不会生产单独文件，可以显示行和列 devtool: \"eval-source-map\", //3) 不会产生列，但是是一个单独映射文件 // devtool: \"cheap-module-source-map\", //产生后保留起来 // // 4) 不会生成文件， 继承后可以在文件中，不会产生列 // devtool: \"cheap-module-eval-source-map\", watch 用法​ 修改代码，实时打包。编译 ​ webpack-dev-server：默认 watch 开启，为 true， 123456watch: true,watchOptions: &#123; poll: 1000, // 每秒检测多少次改变 aggregateTimeout: 500, // 防抖 毫秒之后在执行 ignored: /node_modules/ //忽略文件&#125;, 小插件应用clean-webpack-plugin :清空之前的打包目录文件123let &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");new CleanWebpackPlugin();// new CleanWebpackPlugin(\"./dist\") copy-webpack-plugin ：指定目录下的文件打包到 dist 文件下 ，如 public123let copyWebpackPlugin = require(\"copy-webpack-plugin\");new copyWebpackPlugin([&#123; from: \"./public\", to: \"./\" &#125;]); //把public目录中的文件copy到dist下，// new copyWebpackPlugin([&#123; from: \"./public\", to: \"./public\" &#125;]) //把public目录中的文件copy到dist下的public文件夹下， 跨域问题12345678910111213141516171819// 1）devServer: &#123; proxy: &#123; '/api': &#123; target: \"http://localhost:3000\", // 遇到 ‘/api’的代理到这个host上 pathRewrite: &#123; \"/api\": \"\" &#125; //重写，把请求路径中的/api=&gt; '' &#125; &#125; // //2） mock数据的 webpack-server-dev就是一个express服务，所以 // before(app) &#123; // app.get(\"/user\", (req, res) =&gt; &#123; // res.json(&#123; name: \"change All\" &#125;); // &#125;); // &#125;&#125;// 3)通过在express node服务上直接启动webpack, 端口用的就是webpack的端口 express的中间件 webpack-dev-middleware 优化篇 noparse :打包时候不用在继续查找依赖看他是否有依赖 123456module.exports = &#123; //... module: &#123; noParse: /jquery|lodash/ &#125;&#125;; 2) rules:中 exclude,include 12345678910module.exports = &#123; //... rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, include: path.resolve(\"src\") &#125; ]&#125;; 3) IgnorePlugin :导入模块中多余模块的剔除 12345678//如moment引入了很多语言包，先去掉所有的语言包plugins:[ new webpack.IgnorePlugin(/\\.\\/locale/, /moment/);]//然后在使用的地方要手动引入语言import 'moment/locale/zh-cn';moment.locale('zh-cn'); dllPlugin ==》 DllReferencePlugin: 拆分 happypack 多线程打包 //项目小不要用， 1234567891011121314151617181920212223242526272829303132333435363738394041let happypack = require('happypack')//...module:&#123; rules:[ //... &#123; test: /\\.js$/, include: path.resolve(__dirname, \"src\"), exclude: /node_modules/, use: 'happypack/loader?id=js' &#125;, &#123; test: /\\.css$/, use: 'happypack/loader?id=css' &#125; ]&#125;plugins:[ new happypack(&#123; id:'js', use:[ &#123; loader:'babel-loader', options:&#123; // 用babel-loader 把es6-es5 presets: [\"@babel/preset-env\"] &#125; &#125; ] &#125;) new happypack(&#123; id:'css', use:[ &#123; loader:'style-loader,css-loader', &#125; ] &#125;) //...] 抽离公共代码 1234567891011121314151617181920optimization:&#123; splitChunks:&#123; // 分割代码块 cacheGroups:&#123; // 缓存组 common:&#123; //公共的模块 的抽离 chunks:&apos;initial&apos;,// 开始入口的时候抽离 ， minSize:1, // 文件大小大于多少字节抽离， minChunks:3 // 使用次数大于多少时候抽离 &#125;, vendor:&#123; //第三方模块的抽离 priority:1, // 提升优先级（公用模块应用了第三方东西） test:/node_modules/, // 把你抽离出来 chunks:&apos;initial&apos;, minSize:1, minChunks:3 &#125; &#125; &#125;&#125; 7) webpack 自带优化 用 import 在生产模式下，会自动去掉没用的代码， tree-shaking: 把没用的代码，自动剔除 require 引入不行 scope hosting 作用域提升 ：在 webpack 中自动把一些代码简化了 123let a = 1;let b = 2;let c = a + b; //打包时候会直接c =3,上面的a，b去掉了 懒加载1234//es6草案中的语法import(\"./utils//test.js\").then(data =&gt; &#123; console.log(data.default);&#125;);","categories":[{"name":"Web,打包工具","slug":"Web-打包工具","permalink":"https://pszh.github.io/categories/Web-打包工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://pszh.github.io/tags/webpack/"}]},{"title":"React小白学习","slug":"react 小白学习篇","date":"2020-01-16T02:06:24.653Z","updated":"2020-01-16T02:06:24.654Z","comments":true,"path":"2020/01/16/react 小白学习篇/","link":"","permalink":"https://pszh.github.io/2020/01/16/react 小白学习篇/","excerpt":"","text":"基本概念 React.js React.js 是 React 的核心库，在应用中必须先加载核心库。 ReactDOM.js ReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement JSX JSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。 组件 组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发 VIRTUAL DOM React 抽象出来的虚拟 DOM 树 （其实就是内存中的一个js 对象），虚拟树是 React 高性能的关键。 单向数据流：one-way reactive data flow React 应用的核心设计模式，数据流向自顶向下 react 工作原理 state,props 数据 jsx 模版 数据+ 模版 生成虚拟 DOM(就是一个 js 对象，用来描述真实 DOM) eg: { ‘div’, { id : ‘abc’ }, [‘span’,{},’hello’]} 用虚拟 DOM 结构生成真实 DOM,来显示 eg : hello state 发生变化 数据+模版 生成 新的 虚拟 DOM eg : { ‘div’, { id : ‘abc’ }, [‘span’,{},’bye’]} 比较原始虚拟 DOM 和新虚拟 DOM 的区别 (用到 diff 算法，同层比对)，找到区别 eg: span 中内容 直接操作 DOM, eg : 改变 span 中内容 组件生命周期​ https://raw.githubusercontent.com/pszh/webLearn/master/%E6%9C%89%E9%81%93%E5%9B%BE%E7%89%87/react%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png componentWillMount 条件：第一次渲染阶段在调用 render 方法前会被调用 作用：该方法在整个组件生命周期只会被调用一次，所以可以利用该方法做一些组件内部的初始化工作 componentDidMount 条件：第一次渲染成功过后，组件对应的 DOM 已经添加到页面后调用 作用：此时组件对应的 DOM 已经存在，我们可以在这个时候做一些依赖 DOM 的操作或者其他的一些如请求数据，和第三方库整合的操作。如果嵌套了子组件，子组件会比父组件优先渲染，所以这个时候可以获取子组件对应的 DOM componentWillReceiveProps(newProps) 条件：当组件获取新属性的时候，第一次渲染不会调用 作用：这个时候可以根据新的属性来修改组件状态 12345componentWillReceiveProps: function(nextProps) &#123; this.setState(&#123; isShow: nextProps.likeCount &gt; this.props.likeCount &#125;);&#125; 注意：这个时候虽说是获取新属性，但并不能确定属性一定改变了，例如一个组件被多次渲染到 DOM 中 123456789101112131415eg:var Component = React.createClass(&#123; componentWillReceiveProps: function(nextProps) &#123; console.log('componentWillReceiveProps', nextProps.data.bar); &#125;, rener: function() &#123; return &lt;div&gt; &#123;this.props.data.bar&#125; &lt;/div&gt; &#125; &#125;); var container = document.getElementById('container'); var mydata = &#123;bar: 'drinks'&#125;; ReactDOM.render(&lt;Component data=&#123;mydata&#125; /&gt;, container); ReactDOM.render(&lt;Component data=&#123;mydata&#125; /&gt;, container); ReactDOM.render(&lt;Component data=&#123;mydata&#125; /&gt;, container); 结果会输出两次 componentWillReceiveProps，虽然属性数据没有改变，但是仍然会调用 componentWillReceiveProps 方法。 shouldComponentUpdate(nextProps, nextState) 条件：接收到新属性或者新状态的时候在 render 前会被调用（除了调用 forceUpdate 和初始化渲染以外） 作用：该方法让我们有机会决定是否重渲染组件，如果返回 false，那么不会重渲染组件，借此可以优化应用性能 componentWillUpdate(nextProps, nextState) 条件：当组件确定要更新，在 render 之前调用 作用：这个时候可以确定一定会更新组件，可以执行更新前的操作 注意：方法中不能使用 setState ，setState 的操作应该在 componentWillReceiveProps 方法中调用 componentDidUpdate(prevProps, prevState) 条件：更新被应用到 DOM 之后 作用： 可以执行组件更新过后的操作 ​ React 与 DOM获取 DOM 元素从组件的生命周期中，Dom 真正添加到 html 中 hook 是， componentDidMount componentDidUpdate 这两个函数中可以获取到，react 提供了两种获取方式 findDOMNode() 123456789var MyComponent = React.createClass(&#123; render: function() &#123; return &lt;div&gt; .... &lt;/div&gt;; &#125;, componentDidMount: function() &#123; var $root = ReactDOM.findDOMNode(this); console.log($root); &#125;&#125;); 注意：此方法不能用到无状态组件上，且只能获取到 root 元素，（如果 dom 多层级，获取子级元素需要 refs） Refs 每个组件都有 this.refs 属性， 123456789101112131415var MyComponent = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;button ref=\"btn\"&gt;...&lt;/button&gt; &lt;a href=\"\" ref=\"link\"&gt;&lt;/a&gt; &lt;/div&gt; ); &#125;, componentDidMount: function() &#123; var $btn = this.refs.btn; var $link = this.refs.link; console.log($btn, $link); &#125;&#125;); reduxredux 的引入：不同组件之间的通讯时 由于 层级太深 导致麻烦， 所以引入 redux 的 Store 统一管理 redux = flux + reducers redux 的工作流https://github.com/pszh/webLearn/blob/master/%E6%9C%89%E9%81%93%E5%9B%BE%E7%89%87/redux%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png 描述 ： 组件通过 dispatch 发起 action store 把之前的数据 state 和 actions 转发给 reducers reducers 根据 actions.type 操作 state，并返回新 state 到 store 中 store 把 新 state 替换老 state store 发生改变 组件 会感知到改变，然后 setState ( 组件要注册 store.subscribe()监听) 代码中使用安装1npm install redux —save 编写 src 下建 store 文件夹 =》 index.js state 中心 12345import &#123; createStore &#125; from \"redux\";//第二步创建的import reducer from \"./reducer.js\";const store = createStore(reducer);export default store; store =&gt; reducer.js state 操作，管理中心 123456789101112131415//默认初始化的state 状态const defaultState = &#123; inputValue: \"\"&#125;;export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case \"changeInputValue\": return &#123; ...state, inputValue: action.value &#125;; break; &#125; return state;&#125;; 组件中引入 1234567891011121314151617181920212223import store form './store';// 组件的 constructor 构造方法中constructor(props)&#123; super(props); this.handleInputChange = this.handleInputChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); this.state = store.getState(); //订阅store的改变 dispacth之后store改变 store.subscribe(()=&gt;&#123; this.setState(store.getState()); &#125;);&#125;//发起actionhandleInputChange(value)&#123; const actions = &#123; type : 'changeInputValue', value: value &#125; store.dispatch(actions);&#125; opt : 这个里面的 actions.type 可以统一管理， 在 src/store 建一个 actionsTypes.js 文件，然后去引用对应变量 1export const CHANGE_INPUT_VALUE = \"changeInputValue\"; actions 在 组建中去创建太过分散，统一管理 ，在 src/store 建一个 actionsCreator.js 文件， 123456import &#123; CHANGE_INPUT_VALUE &#125; from \"./actionTypes\";//对应组件中使用这个去创建对应actionexport const getInputChangeAction = value =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;); //组件中的 handleInputChangehandleInputChange(value){ const actions = getInputChangeAction(value) store.dispatch(actions);} 1234567891011121314151617181920212223242526272829303132**注意** ：- store 是唯一的 （整个项目就一个 createStore()）- 只有 store 才能改变 (reducer 中返回的 state 也是给到 store 中改变 state 的)- reducer 函数必须是纯函数，（固定输入，就有固定输出，不能有异步操作等，）复习：四个函数 createStore() ; getState() ; dispatch() ; subscribe()### redux 异步操作 redux—thunk- **原理**：可以让 actions 是一个函数，- **安装**：npm install redux-thunk —save- **引入**：src/store/index.js```jsimport &#123; createStore,applyMiddleware, compose &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;//第二步创建的import reducer from &apos;./reducer.js&apos;;// 下面两个为了使用redux-devtools这个浏览器插件const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const enhancer = composeEnhancers( applyMiddleware(thunk),);const store = createStore( reducer,enhancer );//不使用浏览器插件的话//const store = createStore( reducer, applyMiddleware(thunk) );export default store; 使用：src/store/actionCreators.js 12345678910111213141516171819202122import &#123; CHANGE_INPUT_VALUE, GET_HTTP_DATA &#125; from \"./actionTypes\";import axios from \"axios\";//普通的 actionexport const getInputChangeAction = value =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;);//异步actionexport const getHttpData = () =&gt; &#123; return (dispatch, getState) =&gt; &#123; axios.get(\"/list.json\").then(res =&gt; &#123; const data = res.data; //调用一个普通action 去reducer const action = getInputChangeAction(data); dispatch(action); &#125;); &#125;;&#125;;//组件里面需要掉用的是store.disPatch(getHttpData()); redux 异步操作 redux—saga 原理：通过捕获，拦截对应的 action，然后调用自己的（异步）方法， 这个方法中再去发起另一个 aciotns 出发 reducer 安装：npm install redux—saga —save 引入：src/store/index.js 123456789101112import &#123; createStore, applyMiddleware, compose &#125; from \"redux\";import createSagaMiddleware from \"redux-saga\";import reducer from \"./reducer.js\";//异步操作的集合import Sagas from \"./sagas\";// create the saga middlewareconst sagaMiddleware = createSagaMiddleware();// mount it on the storeconst store = createStore(reducer, applyMiddleware(sagaMiddleware));// run the sagasagaMiddleware.run(Sagas);export default store; src/store/sagas.js 1234567891011121314151617181920import &#123; takeEvery, put &#125; from 'redux-saga/effects';import &#123; CHANGE_INPUT_VALUE, GET_HTTP_DATA &#125; from './actionTypes';import &#123; getInputChangeAction &#125; form './actionCreators';import axios from 'axios';function* getHttpData()&#123; const res = yield axios.get('/list.json'); // 发起一个新actions 出发reducer const actions = getInputChangeAction(res.data); // 不是用dispatch 了 yield put( actions );&#125;// generator 函数function * Sagas()&#123; // 拦截到 action.type = GET_HTTP_DATA, 调用getHttpData函数 yield takeEvery(GET_HTTP_DATA,getHttpData)&#125;export default Sagas; 使用：组件中 1store.dispatch(&#123; type: GET_HTTP_DATA &#125;); React-redux 简介 ：第三方模块，更方便的在 react 组件中使用 redux 安装： 1npm install react-redux 使用： provider 1234567891011121314import React from \"react\";import ReactDOM from \"react-dom\";import TodoList from \"./TodoList\";import &#123; Provider &#125; from \"react-redux\";import store from \"./store\";const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt;);const rootElement = document.getElementById(\"root\");ReactDOM.render(App, rootElement); connect() 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from \"react\";import &#123; connect &#125; from \"react-redux\";import &#123; getInputChangeAction &#125; from \"./actionCreators\";class TodoList extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.props.inputValue&#125; onChange=&#123;this.props.handleInputChange&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;/**把store中的state转到组件的props**/const mapStateToProps = state =&gt; &#123; return &#123; inputValue: state.inputValue &#125;;&#125;;/** store.dispatch, props**/const mapDispatchToProps = dispatch =&gt; &#123; return &#123; handleInputChange(e) &#123; const action = getInputChangeAction(e.target.value); dispatch(action); &#125; &#125;;&#125;;export default connect(mapStateToProps, mapDispatchToProps)(TodoList); 注意：Provider 提供了 store,里面的组件才可以使用 connect() OPT​ 项目变大的时候所有的代码逻辑都放入到单个 reducer 函数中都将会让程序变得不可维护，所以需要拆分开 查分到每一个组件的上面，每个组件上建立一个 store/reducer.js 文件，合并用到combineReducers 1234567891011//合并 reducer 代码import &#123; combineReducers &#125; from 'redux';// 拆分出来的reducer ,里面的写法和 之前的src/store/reducer.js 一样import headerReducer form '../common/header/store/reducer';export default combineReducers(&#123; header: headerReducer&#125;);// 这个时候组件中的mapstateToprops 要用 state.header.*** 去赋值了 数据的 state 有可能不小心被改变了，这个时候可以引入一个immutable 组件，然后用 redux-immutable 去统一数据格式 1234567891011121314151617181920212223242526272829303132333435363738394041//安装npm install immutable --save// 然后是 reducer.js 文件import &#123; fromJs &#125; from 'immutable';const defaultState = fromJs(&#123; inputValue:'',&#125;)export default (state = defaultState ,action ) =&gt; &#123; switch(action.type)&#123; case 'changeInputValue': //设置值 return state.set('inputValue',action.value); break; &#125; return state;&#125;// 组件中mapstateToprops=(state)=&gt;&#123; return &#123; //没有拆分 reducer 时 inputValue: state.get('inputValue'), // 拆分reducer时 （前提引入react-immutable） focuse: state.get('header').get('focuse'), //或 focuse: state.getInt(['header' , 'focuse']), &#125;&#125;// 安装 react-immutablenpm install react-immutable// 组件的reducer 中 (下面的引入改变)import &#123; combineReducers &#125; from 'redux-immutable';// 拆分出来的reducer ,里面的写法和 之前的src/store/reducer.js 一样import headerReducer form '../common/header/store/reducer';export default combineReducers(&#123; header: headerReducer&#125;); react-router### 安装： 12npm run react-router-dom// react-router-dom 基于react-router，加入了在浏览器运行环境下的一些功能，例如：Link组件，会渲染一个a标签，Link组件源码a标签行; BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用window.location.hash和hashchange事件构建路由 使用：123456789101112131415161718import React, &#123; Component &#125; from \"react\";import &#123; Provider &#125; from \"react-redux\";import &#123; BrowserRouter, Route &#125; from \"react-router-dom\";import store from \"./store\";class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route path=\"/\" exact render=&#123;() =&gt; &lt;div&gt; home &lt;/div&gt;&#125; /&gt; &lt;Route path=\"/detail\" exact render=&#123;() =&gt; &lt;div&gt; detail &lt;/div&gt;&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ); &#125;&#125; api 文档 ：https://blog.csdn.net/debbyDeng/article/details/84555817 Route: 最重要的模块，主要职责是当 location 匹配路由时，会将 UI render 出来 Link: 进入页面路由的链接 Router: 所有路由组件最底层的接口， redirect:跳一个新路由，新 location 将覆盖 history stack 中的当前 location NavLink: link 的特殊版本，当匹配当前 url 时，会给当前 Link 添加样式 prompt: 阻止用户跳转路由时的提示，配合 router 的 getUserConfirmation 使用 - MemoryTouter：把 url 保存在内存中，RN，测试等使用 ## ​","categories":[{"name":"Web","slug":"Web","permalink":"https://pszh.github.io/categories/Web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://pszh.github.io/tags/React/"}]},{"title":"Node 常用命令 与版本控制","slug":"node ","date":"2019-01-18T02:15:09.203Z","updated":"2019-01-18T02:15:09.204Z","comments":true,"path":"2019/01/18/node /","link":"","permalink":"https://pszh.github.io/2019/01/18/node /","excerpt":"","text":"Node 常用命令清除 node_modules 文件 ：rm -rvf node_modules/ 安装模块 全局安装 npm install -g n （全局的 npm install -g n@..） 安装到项目中的depend : npm install express 安装到项目devD : npm install express –save-dev 卸载模块：npm uninstall express 更新模块： npm update express 清本地缓存 ：npm cache clear 查看全局安装模块 ：npm list -g node 版本控制 n安装 通过npm安装 npm install -g n 通过源代码 12345$ git clone https://github.com/visionmedia/n.git$ cd n$ make install如果需要配置环境变量 在最后一条命令前加 PREFIX前缀$ PREFIX=$HOME make install #将n安装到~/bin/n 使用和安装node en安装制定版本 n 0.8.17 卸载 sudo n - 0.8.17 切换版本 输入n来选择已经安装的node版本，或者通过^C取消选择 1234$ n 0.8.17 ο 0.10.26 0.11.12 查看所有可安装版本 node ls (ls是list缩写)","categories":[{"name":"Web","slug":"Web","permalink":"https://pszh.github.io/categories/Web/"}],"tags":[{"name":"node","slug":"node","permalink":"https://pszh.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://pszh.github.io/tags/npm/"}]},{"title":"esLint","slug":"eslint","date":"2019-01-18T02:15:09.203Z","updated":"2019-01-18T02:15:09.203Z","comments":true,"path":"2019/01/18/eslint/","link":"","permalink":"https://pszh.github.io/2019/01/18/eslint/","excerpt":"","text":"esLint 介绍​ 团队开发 ，统一代码风格 ​ 命令介绍 https://eslint.org/docs/user-guide/command-line-interface 安装 &amp; 初始化配置文件全局安装​ 1. npm install -g eslint ​ 2. eslint –init ​ 然后一系列的配置 本地项目​ 1. npm install eslint –save-dev ​ 2. ./node_modules/.bin/eslint –init (需要当前项目路径) ​ 然后一系列配置 配置#### eslintrc文件配置 ​ 规则配置文件 ， 通过上面 init 方式配置的都是在项目最外层生成一个配置文件， （当然你也可以在package.json） ​ 官方文档 https://eslint.org/docs/user-guide/configuring 123456789101112131415161718192021222324252627282930313233343536&#123; \"env\": &#123; // 指定环境 \"node\": true, \"commonjs\": true, \"es6\": true &#125;, \"globals\": &#123; //指定全局 \"var1\": true, \"var2\": false &#125; \"plugins\":&#123; //配置插件 先通过 npm install --save-dev eslint-plugin-react 最好在init前安装 \"eslint-plugin-react\", &#125; \"extends\": \"eslint:recommended\", //扩展配置文件 \"parserOptions\": &#123; //指定解析器选项 \"ecmaVersion\": 2016 &#125;, \"rules\": &#123; // 配置规则 https://eslint.org/docs/rules/ \"indent\": [ \"error\", \"tab\" 使用tab键 ], \"linebreak-style\": [ \"error\", \"unix\" ], \"quotes\": [ \"error\", \"single\" 单引号 ], \"semi\": [ \"error\", \"always\" 使用分号 ] &#125;&#125; 部分文件忽略检测 在 eslintrc同目录下创建 .eslintignore 文件 1234567# /node_modules/* and /bower_components/* 这个是默认忽略的# Ignore built files except build/index.js 忽略build下的文件除了 index.jsbuild/*!build/index.js# 忽略 dist目录下文件dist/* 手动检测代码，自动修复格式化1234eslint --ext src //手动检测src文件夹下的.js --ext 默认 .js eslint --ext .js .vue src //手动检测src下的 .js .vue 文件eslint --fix src//修复大部分的格式问题 结合webpack使用​ 安装一个eslint-loader 的loader​ 12345module:&#123; preLoaders: [ //安全起见用这个preLoaders, 如果用loaders,且使用了babel-loader，那babel-loader必须在eslint-loader之前配置 &#123; test: /\\.js$/, loader: &quot;eslint-loader&quot;, exclude: /node_modules/&#125; ], &#125; git 代码提交前检测​ 这个时候不得不提一下git hook了（https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90）​ ​ 查看当前目录下的hook文件 cd .git/hooks &amp;&amp; ls ​ 然后看到 很多.sample 的文件，前面对应git 钩子一些操作， 而 .sample 后缀都是未启动状态，对应的钩子要生效，需要用shell脚本把.sample去掉，如何用js去掉， ​ 这里才是重点 (⚠️必须在git仓库添加之后) 安装pre-commit 1npm install pre-commit --save-dev 配置package.json 123456789101112131415第一种//执行静态文件检查\"scripts\": &#123; \"lint\": \"eslint --ext .js --cache --fix src\", //保证eslint在提交时会校验src目录下的js文件 &#125;, \"pre-commit\": [ \"lint\", ]第二种 //只校验提交代码\"scripts\": &#123; \"lint\": \"eslint src --ext .js --cache --fix\", \"pre-lint\": \"node check.js\"//https://www.jianshu.com/p/072a96633479&#125;,\"pre-commit\": [ \"pre-lint\",] 制定自己的规则https://eslint.org/docs/user-guide/command-line-interface 其他的配置 standardjs：https://standardjs.com/readme-zhcn.html （集成度很好 ，包括git hook） prettier：https://zhuanlan.zhihu.com/p/34188596","categories":[{"name":"Web","slug":"Web","permalink":"https://pszh.github.io/categories/Web/"}],"tags":[{"name":"eslint","slug":"eslint","permalink":"https://pszh.github.io/tags/eslint/"}]}]}